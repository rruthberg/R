%Hybrid MCMC sampler
%MH in Gibbs, mixing with random walk
%what about block size?
clear all
t1 = 1851;
td1=1963;
vartheta=0.5;
rho=0.05;
d=2; %number of blocks / d-1 is the # breakpoints?
N = 10000; %sample size

%%%%%%%%%%%%%%%%%%%%%%%%%
%Initialize variables:
tau =[1851.20260095825;1851.63244353183;1851.96919917865;1851.97467488022;1852.31416837782;1852.34702258727;1852.35797399042;1852.38535249829;1852.97672826831;1853.19575633128;1853.22861054073;1853.31895961670;1853.49965776865;1854.13483915127;1856.39630390144;1856.50581793292;1856.53867214237;1856.61806981520;1857.13826146475;1857.40383299110;1857.58179329227;1858.09103353867;1858.15400410678;1858.40588637919;1858.94524298426;1860.12525667351;1860.16906228611;1860.59069130732;1860.85078713210;1860.91923340178;1860.97125256674;1861.18480492813;1861.73785078713;1861.83641341547;1862.13757700205;1862.89322381930;1862.93702943190;1863.17796030116;1863.79397672827;1863.93908281999;1863.98562628337;1865.45859000685;1865.97056810404;1866.06365503080;1866.34017796030;1866.45242984257;1866.83299110199;1866.94798083505;1866.95071868583;1867.63518138262;1867.85420944559;1867.86242299795;1868.74948665298;1868.90280629706;1868.98767967146;1869.25051334702;1869.44216290212;1869.55441478439;1869.80903490760;1869.87474332649;1870.12388774812;1870.51540041068;1870.55920602327;1870.63312799452;1871.02737850787;1871.15058179329;1871.16700889802;1871.73648186174;1871.81587953457;1872.12251882272;1872.24024640657;1872.76865160849;1873.13552361396;1874.28542094456;1874.54551676934;1874.88774811773;1874.98083504449;1875.32854209446;1875.92539356605;1875.93086926763;1875.93086926763;1876.96577686516;1877.06433949350;1877.10540725530;1877.19028062971;1877.77891854894;1877.80903490760;1878.18412046544;1878.19507186858;1878.23613963039;1878.43326488706;1878.69609856263;1879.03559206023;1879.17248459959;1879.50102669405;1880.05681040383;1880.53867214237;1880.68925393566;1880.94387405886;1881.10540725530;1881.96783025325;1882.12936344969;1882.29637234771;1882.29911019849;1882.33470225873;1882.85215605750;1883.79671457906;1883.85147159480;1884.07323750856;1884.85626283368;1885.16837782341;1885.46406570842;1885.97878165640;1886.61670088980;1886.69336071184;1886.75359342916;1886.92060232717;1887.13415468857;1887.40520191650;1888.29774127310;1889.05065023956;1889.19849418207;1889.79260780288;1890.10198494182;1890.18959616701;1891.25188227242;1891.66529774127;1892.65366187543;1893.50787132101;1894.47707049966;1895.31759069131;1896.07049965777;1896.28405201917;1896.33059548255;1899.62970568104;1901.39288158795;1902.67145790554;1905.05612594114;1905.18754277892;1905.52429842574;1906.77275838467;1908.13620807666;1908.27036276523;1908.62902121834;1909.12731006160;1909.82546201232;1910.35660506502;1910.96988364134;1912.51950718686;1913.78439425051;1914.40862422998;1916.61533196441;1918.03080082136;1922.52908966461;1922.67693360712;1923.56947296372;1927.16153319644;1928.11430527036;1930.15400410678;1930.74811772758;1931.07665982204;1931.82956878850;1931.88432580424;1932.06502395619;1932.86447638604;1932.87542778919;1933.88295687885;1934.72347707050;1935.64339493498;1935.69541409993;1936.59616700890;1937.49965776865;1938.35386721424;1939.82135523614;1940.21834360027;1940.42368240931;1941.42026009583;1941.52156057495;1941.57357973990;1942.00068446270;1942.12936344969;1942.48254620123;1946.94524298426;1947.02464065708;1947.61875427789;1947.63791923340;1947.68720054757;1951.40520191650;1957.88295687885;1960.48939082820;1962.21971252567]';

theta=ones(1,N); %vector of theta values
t=[t1 1880 td1]; % vector of time-values, initial quess
nd = [];
for l = 1:d
    nd = [nd sum( tau < t(l+1) & tau > t(l))]; % counts number of disasters in interval
end
lambda=ones(1,N);%vector of lambda-values
%nd = sum(tau<t2 & tau > t1); %number of disasters in sub-interval, count this initially
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%create matrices for updating parameters
lm =[]; %lambdamatrix
tm = [t(1)*ones(1,N)]; %breakpoitns-matrix
ndm =[]; %matrix of number of disasters in each interval
for j =1:d
    lm = [lm; lambda];
    tm = [tm; t(j+1)*ones(1,N)];
    ndm = [ndm; nd(j)*ones(1,N)];
end
%tm = [tm; t(d+1)*ones(1,N)];
%ndm = [ndm; nd(d)*ones(1,N)];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
alpha = ones(1,d)';
%Hybrid MCMC algorithm, Gibbs on lambda, theta and MH on t.
for k = 1:(N-1);
    %MH-step, simulate breakpoints t
    for j=2:d
        R= rho*(tm(j+1,k)-tm(j-1,k)); %random walk proposal
        eps = R*unifrnd(-1,1);
        tcand = tm(j,k) + eps;
        rando = unifrnd(0,1);
        %The following specifies the acceptance probability using hte
        %marginal distribution of t
        Lcand = lm(j-1,k)^(sum(tau < tcand & tau > tm(j-1,k)))*exp(-lm(j-1,k)*(tcand-tm(j-1,k))); 
        Lk = lm(j-1,k)^(sum(tau < tm(j,k) & tau > tm(j-1,k)))*exp(-lm(j-1,k)*(tm(j,k)-tm(j-1,k))); %note that this has no product! should it?
        alpha(j,k+1)=Lcand/Lk;
        if (rando < min(1, alpha(j,k+1))); 
            tm(j,k+1)=tcand;
        else
            tm(j,k+1)=tm(j,k);
        end
    end
    
    %Gibbs steps last...: simulate theta, lambda
    theta(k+1) = gamrnd(2*(d+1),1/(vartheta+sum(lm(:,k)))); % generate from first marginal posterior
    for i = 1:d
        lm(i,k+1) = gamrnd(2+sum(tau < tm(i+1,k+1) & tau > tm(i,k+1)),1/(theta(k+1)+tm(i+1,k+1)-tm(i,k+1))); % not fully complete, how to incorporate the product?? should work as a preliminary distr
    end
end

%Plot stuff
subplot(2,2,1)
plot(1:N,lm(1,:))
title('t1')
subplot(2,2,2)
plot(1:N,tm(2,:),'.')
title('t2')
subplot(2,2,3)
plot(1:N,theta)
title('t3')
% subplot(2,2,4)
% plot(1:N,tm(4,:))
% title('t4')

    %theta = g(lamda,t,tau)
    %lamdba = h(theta, t, tau)
    %Metropolis-Hastings step according to choice...
        %Draw t* from transition density chosen, proposal kernel 
        %set ti+1 = ... with pr alpha etc., if uniform<alpha ... else
        %symmetric proposal = random walk, acceptance simplifies to min(1,
        %f(z)/f(x) ... we know f(t) up to a constant!
    %multiply with f(tau|theta,lambda,t)
        

%Hybrid MCMC sampler
%MH in Gibbs, mixing with random walk
%what about block size?
%Note that this version is corrected with overlapping intervals, does it
%make sense??
clear all
t1 = 1851;
td1=1963;
vartheta=0.5;
rho=0.05;
d=4; %number of blocks / d-1 is the # breakpoints?
N = 100; %sample size

%%%%%%%%%%%%%%%%%%%%%%%%%
%Initialize variables:
tau =[1851.20260095825;1851.63244353183;1851.96919917865;1851.97467488022;1852.31416837782;1852.34702258727;1852.35797399042;1852.38535249829;1852.97672826831;1853.19575633128;1853.22861054073;1853.31895961670;1853.49965776865;1854.13483915127;1856.39630390144;1856.50581793292;1856.53867214237;1856.61806981520;1857.13826146475;1857.40383299110;1857.58179329227;1858.09103353867;1858.15400410678;1858.40588637919;1858.94524298426;1860.12525667351;1860.16906228611;1860.59069130732;1860.85078713210;1860.91923340178;1860.97125256674;1861.18480492813;1861.73785078713;1861.83641341547;1862.13757700205;1862.89322381930;1862.93702943190;1863.17796030116;1863.79397672827;1863.93908281999;1863.98562628337;1865.45859000685;1865.97056810404;1866.06365503080;1866.34017796030;1866.45242984257;1866.83299110199;1866.94798083505;1866.95071868583;1867.63518138262;1867.85420944559;1867.86242299795;1868.74948665298;1868.90280629706;1868.98767967146;1869.25051334702;1869.44216290212;1869.55441478439;1869.80903490760;1869.87474332649;1870.12388774812;1870.51540041068;1870.55920602327;1870.63312799452;1871.02737850787;1871.15058179329;1871.16700889802;1871.73648186174;1871.81587953457;1872.12251882272;1872.24024640657;1872.76865160849;1873.13552361396;1874.28542094456;1874.54551676934;1874.88774811773;1874.98083504449;1875.32854209446;1875.92539356605;1875.93086926763;1875.93086926763;1876.96577686516;1877.06433949350;1877.10540725530;1877.19028062971;1877.77891854894;1877.80903490760;1878.18412046544;1878.19507186858;1878.23613963039;1878.43326488706;1878.69609856263;1879.03559206023;1879.17248459959;1879.50102669405;1880.05681040383;1880.53867214237;1880.68925393566;1880.94387405886;1881.10540725530;1881.96783025325;1882.12936344969;1882.29637234771;1882.29911019849;1882.33470225873;1882.85215605750;1883.79671457906;1883.85147159480;1884.07323750856;1884.85626283368;1885.16837782341;1885.46406570842;1885.97878165640;1886.61670088980;1886.69336071184;1886.75359342916;1886.92060232717;1887.13415468857;1887.40520191650;1888.29774127310;1889.05065023956;1889.19849418207;1889.79260780288;1890.10198494182;1890.18959616701;1891.25188227242;1891.66529774127;1892.65366187543;1893.50787132101;1894.47707049966;1895.31759069131;1896.07049965777;1896.28405201917;1896.33059548255;1899.62970568104;1901.39288158795;1902.67145790554;1905.05612594114;1905.18754277892;1905.52429842574;1906.77275838467;1908.13620807666;1908.27036276523;1908.62902121834;1909.12731006160;1909.82546201232;1910.35660506502;1910.96988364134;1912.51950718686;1913.78439425051;1914.40862422998;1916.61533196441;1918.03080082136;1922.52908966461;1922.67693360712;1923.56947296372;1927.16153319644;1928.11430527036;1930.15400410678;1930.74811772758;1931.07665982204;1931.82956878850;1931.88432580424;1932.06502395619;1932.86447638604;1932.87542778919;1933.88295687885;1934.72347707050;1935.64339493498;1935.69541409993;1936.59616700890;1937.49965776865;1938.35386721424;1939.82135523614;1940.21834360027;1940.42368240931;1941.42026009583;1941.52156057495;1941.57357973990;1942.00068446270;1942.12936344969;1942.48254620123;1946.94524298426;1947.02464065708;1947.61875427789;1947.63791923340;1947.68720054757;1951.40520191650;1957.88295687885;1960.48939082820;1962.21971252567]';

theta=ones(1,N); %vector of theta values
t=[t1 1880 1920 1945 td1]; % vector of time-values, initial quess
nd = [];
for l = 1:d
    nd = [nd sum( tau < t(l+1) & tau > t(l))]; % counts number of disasters in interval
end
lambda=ones(1,N);%vector of lambda-values
%nd = sum(tau<t2 & tau > t1); %number of disasters in sub-interval, count this initially
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%create matrices for updating parameters
lm =[]; %lambdamatrix
tm = [t(1)*ones(1,N)]; %breakpoitns-matrix
ndm =[]; %matrix of number of disasters in each interval
for j =1:d
    lm = [lm; lambda];
    tm = [tm; t(j+1)*ones(1,N)];
    ndm = [ndm; nd(j)*ones(1,N)];
end
%tm = [tm; t(d+1)*ones(1,N)];
%ndm = [ndm; nd(d)*ones(1,N)];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
alpha = ones(1,d)';
%Hybrid MCMC algorithm, Gibbs on lambda, theta and MH on t.
%PROBLEM: if intervals intersect!! how to solve? separate function for
%counting. Separate function for L.
for k = 1:(N-1);
    %MH-step, simulate breakpoints t
    for j=2:d
        R= rho*(tm(j+1,k)-tm(j-1,k)); %random walk proposal
        eps = R*unifrnd(-1,1);
        tcand = tm(j,k) + eps;
        rando = unifrnd(0,1);
        %The following specifies the acceptance probability using hte
        %marginal distribution of t
        upc=max(tcand, tm(j-1,k));
        lc = min(tcand, tm(j-1,k));
        ups=max(tm(j,k), tm(j-1,k));
        ls = min(tm(j,k), tm(j-1,k));
        Lcand = lm(j-1,k)^(sum(tau < upc & tau > lc))*exp(-lm(j-1,k)*(abs(tcand-tm(j-1,k)))); 
        Lk = lm(j-1,k)^(sum(tau < ups & tau > ls))*exp(-lm(j-1,k)*(abs(tm(j,k)-tm(j-1,k)))); %note that this has no product! should it?
        alpha(j,k+1)=Lcand/Lk;
        if (rando < min(1, alpha(j,k+1))); 
            tm(j,k+1)=tcand;
        else
            tm(j,k+1)=tm(j,k);
        end
    end
    
    %Gibbs steps last...: simulate theta, lambda
    theta(k+1) = gamrnd(2*(d+1),1/(vartheta+sum(lm(:,k)))); % generate from first marginal posterior
    for i = 1:d
        lm(i,k+1) = gamrnd(2+sum(tau < tm(i+1,k+1) & tau > tm(i,k+1)),1/(theta(k+1)+abs(tm(i+1,k+1)-tm(i,k+1)))); % not fully complete, how to incorporate the product?? should work as a preliminary distr
    end
end

%Plot stuff
subplot(2,2,1)
plot(1:N,tm(4,:))
title('t4')
subplot(2,2,2)
plot(1:N,tm(2,:))
title('t2')
subplot(2,2,3)
plot(1:N,theta)
title('theta')
subplot(2,2,4)
plot(1:N,tm(3,:))
title('t3')

    %theta = g(lamda,t,tau)
    %lamdba = h(theta, t, tau)
    %Metropolis-Hastings step according to choice...
        %Draw t* from transition density chosen, proposal kernel 
        %set ti+1 = ... with pr alpha etc., if uniform<alpha ... else
        %symmetric proposal = random walk, acceptance simplifies to min(1,
        %f(z)/f(x) ... we know f(t) up to a constant!
    %multiply with f(tau|theta,lambda,t)
        